### short

- change deployent to use template body rather than template URL
- remove template URL code 

- build_artifacts needs to test lambdas
- build_artifacts needs to push lambdas to s3

- add template code to populate default parameters
- modify validation code so doesn't have to involve defaults 

- move deployment script into cli

### medium

- remove _json suffix from filename, dumping
- add error type to actions (destination/dlq)
- add dlq support to actions
- token api example/support
- layer management application [notes]
- refactor cli api
  - combine lambda test/push, template generation/validation into single step
  - embed all variables in template
  - simple deployment stack
- test codebuild notification handling (CI pipeline)
- test cloudformation remote error handling
- pareto.ci

### long [features]

- metadata schema
- eventbridge lambda destination
- s3 eventbridge notifications
- eventbridge urls
- s3 sync error handling
- lambda alarms
- aws chat
- iam role lockdown
- step functions
- appsync + graphql

### thoughts

- codebuild project ?
  - not sure it's a core component, more like a something one- off
- check metadata components can be optional ?
  - not really possible with current metadata structure which uses objects
  - not even sure is really desirable; may be better to explicitly all keys but then allow them to be empty lists
- flatten nested config items where possible ?
  - no real need if no metadata schema, and possibly not even then
- dashboard should not require specification ?
  - think it's probably best made explicit for now
- add check so type can't appear in component name ?
  - probably too tightly prescriptive
- replace action with function ?
  - no particular need, esp if no type checking as per above
- consider nesting events under router ?
  - no think things are fine as they are 
- table stream shouldn't be defined as part of config ?
  - no is fine; is already abstracted somewhat
- simplify validate_async_errors
  - no is fine
- use QueueNamePrefix when looking up queues ?
  - probably not worth it
- failure options for s3 notifications ?
- is s3 invocation of lambda is synchronous ?
- compact dsl ?
- clean up all init resource/output functions ?
  - not worth it
- avoid userpool/userpool_ nomenclature ?
  - not worth it
- stop symlink creating pareto2/pareto2 ?
  - probably overkill at this stage
- action to validate binding uniqueness ?
  - probably overkill at this stage
- remove eventbus discoverer ?

### done

- simplify layer code in deploy_stack.py by reference to md.layers
- move lambdas inline
- remove template generation, template validation, lambda test, lambda push from deployent script 
- change deploy stack to ask for filename and create template
- create artifacts to dump output file name
- check a Template can be initialised from a JSON struct
- move parameters inline into deployment
- remove stuff below flag in create artifacts
- remove flag from deploy stack
- split deploy stack into two scripts, create artifacts and deploy stack
- move deployment related code into pareto deploy 
- flatten both pareto deploy and pareto cli
- consider renaming pareto deploy as pareto actions 
- run_tests.py no longer finding any lambdas
- move test into pareto core
- remove errors restriction on actions bound to queues
- rename packages as pareto.core, pareto.cli
- scripts/deploy/redeploy_api.py will fail
  - check all scripts which rely on outputs
- raise error if events pattern is not a dict
- add pattern matching utility
- remove eventbridge message analyzer
- add back setenv.sh
- check where setenv has gone
- stuff doesn't get produced if `-dashboard` suffix not specified
- remove types from names
- errors queue can't have its own dlq
- validate apigw type
- validate userpool if cognito
- new simple, cognito apigw
- add type to apigw
- add router suffix
- add event, timer resource suffixes
- extend resource names suffixes for subordinate types
- refactor sqs handlers with decorator which tests for http prefix
- cdk/__init__.py function to initialise component map
- queue did not fail when bad action listed
- add errors/sync handling to queues
- rename errors as errors/async
- new errors/sync
- bind table to errors/sync
- simplify/harmonise timer/root, errors tests
- fetch_queue helper
- timer root should set queue in env using name
- add (router) prefix to events lookup
- drain_sqs to drain by name ?
- rename events-queue as events-target queue
- remove self.queues state
- teardown_events to lookup and delete sqs queue
- delete queue based on name
- queue listing utilities
- bucket test code to work with objects
- fix lambda test error
- check deletion of rules and targets
- re- test router code
- pass router object
- handle multiple routers
- use local table definition
- handle multiple tables
- handle multiple buckets
- replace EventsEventBusName/EventsQueueName/EventsRulePrefix with router name
- check failure options for s3 notification configuration
- check for invalid error handlers
  - if bound to apigw
  - if bound to table
  - if bound to bucket
  - if bound to queue
- remove error handlers from bucket/table configurations
- rename binding as mapping
- validate table errors attr
- add back table error mapping
- check online before performing layers check
- uncomment layers check
- validate errors field against action
- add errors field to action which triggers generation of event config
- define async error function and queue
- remove md.errors 
- remove queue errors dlq
- comment out event config generation
- don't define event_config for sync actions
- refactor queues.py to work off queue config not action config
- refactor queue config in pareto2-demo
- add new metadata queue class
- validate queue action against actions
- make bucket, table action optional
- replace dynamic imports
- investigate why some stack names are pluralised
- investigate why list of stack names is required in metadata
- pluralise all plural component modules
- check StackName refs
- rename bucket and table as demo-streaming
- validate bucket, table action
- add bucket, table action
- avoid duplicating schema stuff with metadata validation code 
- event action / source validation
- api endpoints against endpoint names 
- event router against routers
- api userpool against userpool names
- endpoint actions against action names
- event action against action names
- timer action against action names
- add cross validation to all cross references
- list all cross references 
- use endpoint["name"] rather than endpoint["action"] in api resource names
- get rid of actions.names
- shouldn't need actions.functions any more
- don't think u really need these `rules` properties
- think timer.rules should reference `name` not `action`
  - see if this allows you to have different `name` and `action` attrs in config
  - repeat for events
- liberate events from actions
- liberate timers from actions
- move timers validation into new md.timers class
- bind endpoints to APIs 
- move endpoint validation code from action into endpoint
- $schema declaration is missing
- investigate why new api template post- endpoints integration is slightly smaller than prior template
- api component to use md.endpoints
- remove endpoints from actions
- separate endpoint from actions
- bind endpoints to apis
- apis to specify user pool
- events to specify router
- add support for list of userpools
- rename users as userpool
- md.routers is blank
- rename routing as events
- rename events as router
- convert buckets and tables to be lists
- convert dash to handle bucket and table lists
- copy config
- allow option to ignore lambdas if required
- test deploy_stack.py false
- remove unauthorised api
- remove self.env declarations from test

